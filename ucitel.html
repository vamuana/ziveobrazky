<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8" />
    <title>≈Ωiv√© obr√°zky ‚Äì Editor √∫lohy</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; }
        body {
            font-family: 'Comic Sans MS', Arial, sans-serif;
            background: linear-gradient(to bottom, #41eafa, #89F8CE);
            color: #4e342e;
            overflow: hidden;
        }
        header {
            background: linear-gradient(to bottom, #fa9494, #FFA07A);
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 4px solid #FFF4B5;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
        }
        header .button-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #block-library {
            background: #F5F5F5;        /* any light background */
            width: 65%;
            height: calc(100% - 2rem);
            float: right;
            overflow-y: auto;
            padding: 0.5rem;
        }
        #block-library .block {
            margin-bottom: 0.5rem;
            cursor: grab;
        }
        .block-children {
            padding-left: 20px;
            border-left: 2px dashed #ccc;
            margin-top: 6px;
        }


        .handle {
            z-index: 10;
            border-radius: 50%;
            display: none;
        }
        .object.selected .handle {
            display: block;
        }
        .resize-handle {
            width: 10px;
            height: 10px;
            background: black;
            position: absolute;
            right: -5px;
            bottom: -5px;
            cursor: nwse-resize;
        }
        .rotate-handle {
            width: 10px;
            height: 10px;
            background: blue;
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            cursor: grab;
        }
        #program-area .block {
            position: relative; /* Required so ::after is positioned relative to the block */
            margin-bottom: 12px; /* Creates enough room for the triangle */
        }

        header button {
            background: #B7F5F4;
            border: 2px solid #FFF4B5;
            padding: 10px 16px;
            border-radius: 14px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 3px rgba(0,0,0,0.1);
        }
        header button:hover {
            background: #ffd1e3;
            transform: translateY(-2px) scale(1.05);
        }
        /* === BLOCK EDITOR (EDIT MODE) === */
        #block-editor {
            position: absolute;
            top: 10%;
            left: 5%;
            width: 90%;
            height: 80%;
            background: #fff;
            border: 2px solid #444;
            border-radius: 8px;
            display: none;       /* hidden until invoked */
            z-index: 50;
            padding: 1rem;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #block-editor h2 {
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
        }
        /* ========================================================================
   BLOCK STYLING
   ======================================================================== */

        #block-palette .block:hover,
        #program-area .block:hover {
            background: #E0F7FA;
            transform: translateY(-2px);
        }

        #program-area .block::after {
            content: "";
            position: absolute;
            left: 50%;
            bottom: 0;
            transform: translate(-50%, 100%);
            width: 14px;
            height: 8px;
            background: inherit;
            clip-path: polygon(0 0, 100% 0, 50% 100%);
        }
        #program-area .block + .block {
            margin-top: -1px;
        }



        .block[data-command="opakuj"] input.block-param {
            background: white;
            color: black;
            font-weight: bold;
            border: none;
            text-align: center;
            margin-left: 6px;
            border-radius: 6px;
        }
        .block[data-command="opakuj"] .block-children {
            background: #ffe5b4;
            margin-top: 8px;
            padding: 10px;
            border-radius: 8px;
            min-height: 40px;
            transition: all 0.2s ease;
        }

        #program-area .block:last-child::after {
            display: none;
        }
        .block {
            color: #fff;
            padding: 10px;
            font-size: 0.95rem;
            font-weight: bold;
            text-align: center;
            cursor: grab;
            transition: transform 0.2s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2);
            border-radius: 6px;
            user-select: none;
        }

        .block:hover {
            transform: translateY(-2px);
        }
        .block[data-command="opakuj st√°le"] .block-children {
            background: #fff3cd;
            margin-top: 8px;
            padding: 10px;
            border-radius: 8px;
            min-height: 40px;
            transition: all 0.2s ease;
        }

        #block-palette {
            background: #E0F7FA;       /* pale blue */
            width: 30%;
            height: calc(100% - 2rem);
            float: left;
            overflow-y: auto;
            padding: 0.5rem;
            position: relative;
        }
        /* Specific block types */
        .block[data-command="≈°tart"]        { background: #87CEEB !important; }
        .block[data-command="dopredu"]      { background: #FFB6C1 !important; }
        .block[data-command="natoƒç"]        { background: #F0E68C !important; }
        .block[data-command="smerom"]       { background: #febe7f !important; }

        .block[data-command="ƒçakaj"]        { background: #98FB98 !important; }
        .block[data-command="opakuj st√°le"] { background: #fcb769 !important; }
        .block[data-command="zme≈à kost√Ωm"]  { background: #78b5f9 !important; }
        .block[data-command="opakuj"]  { background: #B2A5FF !important; }

        #block-palette .block {
            margin-bottom: 0.5rem;
            cursor: grab;
        }
        #block-palette #dielna-btn {
            position: absolute;
            bottom: 0.5rem;
            right: 0.5rem;
            padding: 0.5rem 1rem;
            background: #0288D1;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        #program-area {
            background: #E0E0E0;       /* light grey */
            width: 65%;
            height: calc(100% - 2rem);
            float: right;
            overflow-y: auto;
            padding: 0.5rem;
        }
        #program-area .block {
            margin-bottom: 0.5rem;
            cursor: default;
        }
        #exit-editor-btn {
            position: absolute;
            bottom: 0.5rem;
            left: 50%;
            transform: translateX(-50%);
            padding: 0.5rem 1rem;
            background: #66BB6A;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        /* small helper to highlight the ‚Äúpressed‚Äù Programuj button */
        button#configureProgram.active {
            background: #1976D2;
            color: #fff;
        }
        .block-param {
            width: 40px;
            margin-left: 5px;
            font-weight: bold;
            font-size: 0.9rem;
            border-radius: 4px;
            border: none;
            padding: 2px 4px;
        }

        #scene {
            position: relative;
            height: calc(100vh - 80px);
            background: #ffffff;
            margin: 0 auto;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #sceneCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .object {
            position: absolute;
            width: 100px;
            height: 100px;
            cursor: grab;
            transform-origin: center center;
        }
        .selected {
            outline: 2px solid red;
        }
        .context-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }
        .context-menu button {
            display: block;
            width: 100%;
            background: none;
            border: none;
            padding: 8px 12px;
            text-align: left;
            font-size: 0.95rem;
            cursor: pointer;
        }
        .program-dropdown {
            display: none;
            position: absolute;
            background: white;
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 100;
            top: 100%;
            left: 0;
            min-width: 180px;
        }

        .program-dropdown .item {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            cursor: pointer;
            padding: 4px;
            border-radius: 6px;
            transition: background 0.2s ease;
        }
        .program-dropdown .item:hover {
            background: #e0f7fa;
        }
        .program-dropdown .item img {
            width: 40px;
            height: 40px;
            margin-right: 10px;
            border-radius: 6px;
            object-fit: contain;
        }
        .context-menu button:hover {
            background: #ffe0ec;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>


</head>
<body>
<div id="contextMenu" class="context-menu">
    <button onclick="toggleProgrammable()">Prepn√∫≈• programovanie</button>
</div>
<header>
    <div class="button-group">
        <input type="file" id="backgroundUpload" style="display: none;" accept="image/*,image/svg+xml" />
        <button id="loadBackground">Naƒç√≠taj pozadie</button>
        <input type="file" id="objectUpload" style="display: none;" accept="image/*" multiple />
        <button id="addObject">Vlo≈æ objekt</button>
        <button id="copyObject">Vlo≈æ k√≥piu objektu</button>
        <button id="deleteObject">Zru≈° objekt</button>
        <button id="transformObject">Uprav objekt</button>
        <button id="addCostume">Pridaj kost√Ωm</button>
        <div id="costumePreview"
             style="position: absolute; display: none; top: 60px; left: 20px;
            background: white; border: 2px solid #ccc; padding: 10px;
            border-radius: 10px; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            z-index: 200; max-width: 300px; overflow-x: auto; white-space: nowrap;">
        </div>

        <button id="nextCostume">ƒéal≈°√≠ kost√Ωm</button>

    </div>
    <div class="button-group">
        <div id="programWrapper" style="position: relative;">
            <button id="configureProgram">Programuj</button>
            <div id="programDropdown" class="program-dropdown"></div>
        </div>

        <button id="editText">Vlo≈æ text</button>
        <button id="saveProject">Zapi≈° projekt</button>
        <button id="downloadZip">Stiahni ako ZIP</button>

    </div>
</header>
<main>
    <div id="scene">
        <img id="sceneCanvas" alt="Background" />
    </div>
    <!-- runtime controls -->
    <div id="runtimeControls"
         style="position:absolute; top:100px; right:20px; display:none; z-index:100;">
        <button id="previewStop"
                style="background:#F44336;color:#fff;
                 padding:6px 12px;border:none;border-radius:4px;
                 cursor:pointer; display:none;">
            Zastav
        </button>
    </div>

    <div id="block-editor">
        <h2>Programovanie objektu</h2>
        <!-- at the top of your block‚Äëeditor, e.g. right under the <h2> -->
        <div style="position:absolute; top:1rem; right:4rem; z‚Äëindex:60;">
            <button id="editorRun"
                    style="background:#4CAF50;color:#fff;
                   padding:6px 12px;border:none;border-radius:4px;
                   cursor:pointer;">
                Spusti
            </button>
        </div>

        <button id="close-editor-btn"
                style="position:absolute; top:1rem; right:1rem;
               background:none; border:none;
               font-size:1.5rem; cursor:pointer;">
            ‚úñ
        </button>

        <!-- left: student‚Äôs palette (starts empty) -->
        <div id="block-palette">
            <button id="dielna-btn">Diel≈àa</button>
        </div>

        <!-- middle: student‚Äôs pre‚Äëwritten program -->
        <div id="program-area" ondragover="event.preventDefault()"></div>

        <!-- right: teacher‚Äôs workshop (initially hidden) -->
        <div id="block-library" ondragover="event.preventDefault()" style="display:none;">
            <!-- paste here all your block prototypes, exactly as in ziak.html: -->
            <div class="block" draggable="true" data-command="≈°tart">≈†tart</div>
            <div class="block" draggable="true" data-command="dopredu">
                Dopredu <input type="number" value="10" class="block-param" />
            </div>

            <div class="block block-instance" data-command="opakuj" data-param="3" draggable="true">
                Opakuj <input type="number" value="3" class="block-param" />
                <div class="block-children"></div>
            </div>


            <div class="block" draggable="true" data-command="natoƒç">
                Natoƒç <input type="number" value="90" class="block-param" />
            </div>

            <div class="block" draggable="true" data-command="smerom">Smerom</div>

            <div class="block" draggable="true" data-command="ƒçakaj">ƒåakaj</div>
            <div class="block block-instance" data-command="opakuj st√°le" draggable="true">
                Opakuj st√°le
                <div class="block-children"></div>
            </div>

            <div class="block" draggable="true" data-command="zme≈à kost√Ωm">Zme≈à kost√Ωm</div>
            <!-- ‚Ä¶etc‚Ä¶ -->
        </div>


        <button id="exit-editor-btn">‚úî Hotovo</button>
    </div>


    <div id="textEditorModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:#fff; border:2px solid #CCC; border-radius:12px; padding:20px; z-index:9999; box-shadow:0 4px 8px rgba(0,0,0,0.2); width:400px; max-width:90%;">
        <h2 style="margin-bottom: 10px;">Uprav text zadania</h2>

        <label for="titleInput">N√°zov √∫lohy:</label>
        <input id="titleInput" type="text" style="width:100%; margin-bottom:10px; padding:8px;" />

        <label for="descInput">Popis √∫lohy:</label>
        <textarea id="descInput" rows="5" style="width:100%; padding:8px; font-family:Arial; font-size:16px; color:#000;"></textarea>

        <div style="margin: 10px 0;">
            <label>Font:</label>
            <select id="fontFamilySelect">
                <option value="Comic Sans MS">Comic Sans MS</option>
                <option value="Arial">Arial</option>
                <option value="Verdana">Verdana</option>
                <option value="Courier New">Courier New</option>
            </select>

            <label style="margin-left:10px;">Veƒækos≈•:</label>
            <select id="fontSizeSelect">
                <option value="14px">14</option>
                <option value="16px" selected>16</option>
                <option value="18px">18</option>
                <option value="20px">20</option>
            </select>

            <label style="margin-left:10px;">Farba:</label>
            <input type="color" id="fontColorInput" value="#000000" />
        </div>

        <div style="text-align:right; margin-top: 10px;">
            <button onclick="closeTextEditor(true)" style="background:#C8E6C9; padding:8px 16px; border-radius:8px; border:none;">‚úÖ Ulo≈æi≈•</button>
            <button onclick="closeTextEditor(false)" style="background:#FFE0EC; padding:8px 16px; border-radius:8px; border:none;">Zru≈°i≈•</button>
        </div>
    </div>


</main>
<script>
    let project;
    let selectedObjectId = null;

    const urlParams = new URLSearchParams(window.location.search);
    const projectPath = urlParams.get('project');
    let isConfiguringProgram = false;
    const configureBtn = document.getElementById('configureProgram');
    const blockEditor   = document.getElementById('block-editor');
    const palette       = document.getElementById('block-palette');
    const programArea   = document.getElementById('program-area');
    const dielnaBtn     = document.getElementById('dielna-btn');
    const exitEditorBtn = document.getElementById('exit-editor-btn');

    async function loadProject() {
        if (projectPath) {
            try {
                const response = await fetch(projectPath);
                const data = await response.json();
                localStorage.setItem("currentProject", JSON.stringify(data));
                return data;
            } catch (e) {
                alert("Nepodarilo sa naƒç√≠ta≈• projekt zo s√∫boru.");
                console.error(e);
                return getDefaultProject();
            }
        }
        return JSON.parse(localStorage.getItem("currentProject")) || getDefaultProject();
    }

    function getDefaultProject() {
        return {
            assignmentTitle: "Nov√° √∫loha",
            assignmentDescription: "Zadaj sem popis √∫lohy.",
            background: "",
            objects: []
        };
    }
    const blockLibrary  = document.getElementById('block-library');

    // Re‚Äëbuilds the left palette from obj.availableBlocks
    // ‚îÄ‚îÄ‚îÄ Replaces your existing buildPalette(obj) ‚îÄ‚îÄ‚îÄ
    function buildPalette(obj) {
        // Clear all previous blocks
        Array.from(palette.querySelectorAll('.block-instance')).forEach(n => n.remove());

        const freq = obj.availableBlocks.reduce((acc, cmd) => {
            acc[cmd] = (acc[cmd] || 0) + 1;
            return acc;
        }, {});

        Object.entries(freq).forEach(([cmd, count]) => {
            const blk = document.createElement('div');
            blk.className = 'block block-instance';
            blk.dataset.command = cmd;
            blk.draggable = true;
            blk.textContent = cmd.charAt(0).toUpperCase() + cmd.slice(1);

            const badge = document.createElement('span');
            badge.textContent = count;
            badge.style.cssText = `
            position: absolute;
            top: 4px;
            right: 8px;
            background: #0288D1;
            color: white;
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 0.75rem;
        `;
            blk.style.position = 'relative';
            blk.appendChild(badge);

            blk.addEventListener('dragstart', onBlockDragStart);
            blk.addEventListener('dragend', onBlockDragEnd);

            palette.insertBefore(blk, dielnaBtn);
        });
    }


    // Allow drops into the palette from the workshop
    palette.addEventListener('dragover', e => e.preventDefault());
    palette.addEventListener('drop', e => {
        e.preventDefault();
        if (!draggedBlock) return;

        const cmd = draggedBlock.dataset.command;
        const obj = project.objects.find(o => o.id === selectedObjectId);

        // Add the command to availableBlocks
        obj.availableBlocks.push(cmd);

        // Refresh the palette to update count
        buildPalette(obj);

        draggedBlock = null;
    });


    function saveProject() {
        localStorage.setItem("currentProject", JSON.stringify(project));
    }

    function renderScene() {
        const scene = document.getElementById('scene');
        const canvas = document.getElementById('sceneCanvas');
        scene.querySelectorAll('.object, .handle').forEach(o => o.remove());
        canvas.src = project.background || "";

        project.objects.forEach(obj => {

            const container = document.createElement('div');
            container.className = 'object';
            container.style.left = obj.x + 'px';
            container.style.top = obj.y + 'px';
            container.style.transform = `rotate(${obj.rotation}deg) scale(${obj.scale})`;
            container.dataset.id = obj.id;
            container.style.position = 'absolute';
            container.style.transformOrigin = 'center center';

            const img = document.createElement('img');
            img.src = obj.image;
            img.style.width = '100%';
            img.style.height = '100%';
            img.draggable = false;
            container.appendChild(img);

            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle handle';
            container.appendChild(resizeHandle);

            const rotateHandle = document.createElement('div');
            rotateHandle.className = 'rotate-handle handle';
            container.appendChild(rotateHandle);

            container.addEventListener('mousedown', startDrag);
            container.addEventListener('click', e => {
                e.stopPropagation();

                // If we‚Äôre in ‚ÄúProgramuj‚Äù mode, open the block editor
                if (isConfiguringProgram) {
                    selectedObjectId = obj.id;
                    openProgramEditorForObject(obj.id);
                    isConfiguringProgram = false;
                    configureBtn.classList.remove('active');
                    return;
                }

                // Otherwise just select the object
                selectObject(obj.id);
            });

            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                selectObject(obj.id);
                const menu = document.getElementById('contextMenu');
                menu.style.display = 'block';
                menu.style.left = `${e.pageX}px`;
                menu.style.top = `${e.pageY}px`;
            });

            resizeHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                const startX = e.clientX;
                const startY = e.clientY;
                const startScale = obj.scale;

                function resizeMove(ev) {
                    const dx = ev.clientX - startX;
                    const dy = ev.clientY - startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    obj.scale = Math.max(0.1, startScale + dist / 200);
                    renderScene();
                }

                function resizeUp() {
                    document.removeEventListener('mousemove', resizeMove);
                    document.removeEventListener('mouseup', resizeUp);
                    saveProject();
                }
                const objId = e.currentTarget.dataset.id;
                if (isConfiguringProgram) {
                    selectedObjectId = objId;
                    openProgramEditorForObject(objId);
                    isConfiguringProgram = false;
                    configureBtn.classList.remove('active');
                    e.preventDefault();
                    return;
                }
                document.addEventListener('mousemove', resizeMove);
                document.addEventListener('mouseup', resizeUp);
            });

            rotateHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                const rect = container.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                function rotateMove(ev) {
                    const dx = ev.clientX - centerX;
                    const dy = ev.clientY - centerY;
                    obj.rotation = Math.atan2(dy, dx) * (180 / Math.PI);
                    renderScene();
                }

                function rotateUp() {
                    document.removeEventListener('mousemove', rotateMove);
                    document.removeEventListener('mouseup', rotateUp);
                    saveProject();
                }

                document.addEventListener('mousemove', rotateMove);
                document.addEventListener('mouseup', rotateUp);
            });
            renderTextPreview();
            scene.appendChild(container);
        });
    }
    function openProgramEditorForObject(objId) {
        const obj = project.objects.find(o => o.id === objId);

        // remember where it started
        obj._origX     = obj.x;
        obj._origY     = obj.y;
        obj._origRot   = obj.rotation;
        obj._origScale = obj.scale;



        const editorRun       = document.getElementById('editorRun');
        const previewStop     = document.getElementById('previewStop');
        const runtimeControls = document.getElementById('runtimeControls');


        previewStop.onclick = () => {
            // reset the object
            resetObject(obj);

            // hide the stop button
            runtimeControls.style.display = 'none';
            previewStop.style.display     = 'none';

            // re‚Äëopen the editor with Spusti visible again
            blockEditor.style.display = 'block';
            editorRun.style.display   = 'inline-block';
        };


        editorRun.onclick = () => {
            // close the popup...
            blockEditor.style.display   = 'none';
            // ...and show only the Zastav button
            runtimeControls.style.display = 'block';
            previewStop.style.display     = 'inline-block';

            const freshBlocks = Array.from(programArea.children)
                .filter(el => el.classList.contains('block-instance'))
                .map(el => serializeBlock(el)); // reuse your existing serializeBlock function

            runBlocksOnObject(obj, () => {
                previewStop.onclick();
            }, freshBlocks);

        };





        // 1) Show the block‚Äêeditor
        blockEditor.style.display = 'block';

        blockLibrary.style.display = 'none';   // start out showing program, not workshop

        // 2) Build left palette from saved availableBlocks
        buildPalette(obj);
// 3a) Only seed templates the first time we open this object
        // Render the saved block structure into the program area
        programArea.innerHTML = "";
        obj.blocks.forEach(blockData => {
            const blockEl = renderBlock(blockData);
            programArea.appendChild(blockEl);
        });
        enableNestedDrops(); // Activate drop zones inside 'opakuj'


// After defining renderBlock(...)
        programArea.innerHTML = "";
        obj.blocks.forEach(blockData => {
            const blockEl = renderBlock(blockData);
            programArea.appendChild(blockEl);
        });
        enableNestedDrops();


        // 4) Hook the ‚ÄúDiel≈àa‚Äù button to show/hide the workshop
        dielnaBtn.onclick = () => {
            const showingLib = blockLibrary.style.display === 'block';
            blockLibrary.style.display = showingLib ? 'none'  : 'block';
            programArea.style.display = showingLib ? 'block' : 'none';
        };


        // 5) Hook the green ‚úî to save both arrays and close
        exitEditorBtn.onclick = () => {
            persistBlockOrder(); // correctly serializes full nested structure
            blockEditor.style.display = 'none';
        };


    }


    // drag handlers (you can copy these from ziak.html too):
    // after
    let dragging = null;
    // ‚îÄ‚îÄ‚îÄ Stub out the ‚Äúinterpreter‚Äù ‚îÄ‚îÄ‚îÄ
    function executeCommands(obj, blocks, onComplete) {
        let i = 0;
        let stepCount = 0;
        const MAX_STEPS = 200;

        function step() {
            if (i >= blocks.length || stepCount >= MAX_STEPS) {
                if (stepCount >= MAX_STEPS) {
                    alert("Program sa zastavil po dosiahnut√≠ maxim√°lneho poƒçtu krokov.");
                }
                return onComplete && onComplete();
            }

            const block = blocks[i++];
            stepCount++;

            switch (block.command) {

                case 'opakuj':
                    const times = parseInt(block.param || 1);
                    const children = block.children || [];
                    const expanded = [].concat(...Array(times).fill(children));
                    blocks.splice(i, 0, ...expanded);
                    break;
                case 'zme≈à kost√Ωm':
                    if (obj.costumes && obj.costumes.length > 0) {
                        const currentIndex = obj.costumes.indexOf(obj.image);
                        const nextIndex = (currentIndex + 1) % obj.costumes.length;
                        obj.image = obj.costumes[nextIndex];
                    }
                    break;
                case 'dopredu': {
                    const steps = parseInt(block.param || 1); // interpret as steps
                    const totalDistance = steps * 50;         // 1 step = 50px
                    let moved = 0;
                    const stepSize = 50;

                    const angleRad = (obj.rotation || 0) * Math.PI / 180;

                    const moveStep = () => {
                        if (moved >= totalDistance) {
                            setTimeout(step, 0); // continue to next command
                            return;
                        }

                        const actualStep = Math.min(stepSize, totalDistance - moved);
                        const dx = Math.cos(angleRad) * actualStep;
                        const dy = Math.sin(angleRad) * actualStep;

                        obj.x += dx;
                        obj.y += dy;
                        moved += actualStep;

                        renderScene();
                        setTimeout(moveStep, 300); // adjust for smooth animation
                    };

                    moveStep();
                    return;
                }



                case 'natoƒç':
                    obj.rotation += parseFloat(block.param || 90);
                    break;

                case 'smerom':
                    obj.x += 50;
                    break;

                case 'ƒçakaj':
                    break;
                case 'opakuj st√°le':
                    i--; // repeat this command
                    break;        }

            renderScene();
            setTimeout(step, 300);
        }

        step();
    }


    function runBlocksOnObject(o, onComplete, liveBlocks = null) {
        const blocksToRun = liveBlocks || o.blocks;
        executeCommands(o, blocksToRun, onComplete);
    }


    function resetObject(o) {
        // your ‚Äúzastav‚Äù logic for a single object
        o.x = o._origX;  o.y = o._origY;
        o.rotation = o._origRot;  o.scale = o._origScale;
        renderScene();
    }



    // (Reattach to your palette blocks if needed)
    // document.querySelectorAll('#block-palette .block-instance')
    //   .forEach(el => el.addEventListener('dragstart', onBlockDragStart));


    // ‚îÄ‚îÄ‚îÄ 2) Drop into the program area: pull exactly one copy ‚îÄ‚îÄ‚îÄ
    programArea.addEventListener('dragover', e => e.preventDefault());
    programArea.addEventListener('drop', e => {
        e.preventDefault();
        if (!draggedBlock) return;

        const obj = project.objects.find(o => o.id === selectedObjectId);
        if (!obj) return;

        const isNew = !draggedBlock.closest('#program-area') && !draggedBlock.closest('.block-children');

        // If new block from palette or workshop
        if (isNew) {
            const cmd = draggedBlock.dataset.command;
            const idx = obj.availableBlocks.indexOf(cmd);
            if (idx === -1) {
                alert(`Nie je dostupn√Ω ƒèal≈°√≠ blok: ${cmd}`);
                return;
            }
            obj.availableBlocks.splice(idx, 1);
            saveProject();
            buildPalette(obj);

            const newBlock = renderBlock({
                command: draggedBlock.dataset.command,
                param: draggedBlock.querySelector('input')?.value ?? null,

                children: []
            });

            const after = getDragAfterElement(programArea, e.clientY);
            if (!after) {
                programArea.appendChild(newBlock);
            } else {
                programArea.insertBefore(newBlock, after);
            }
        } else {
            // üß† Check if we're trying to drag an `opakuj` into its own child:
            if (draggedBlock.contains(e.target)) return; // prevent illegal nesting

            const after = getDragAfterElement(programArea, e.clientY);
            if (!after) {
                programArea.appendChild(draggedBlock);
            } else {
                programArea.insertBefore(draggedBlock, after);
            }
        }
        enableNestedDrops();

        persistBlockOrder();
        draggedBlock = null;
    });



    // üëá Paste this right AFTER the existing programArea drop handler


    // remove a block from the student program on double‚Äëclick
    programArea.addEventListener('dblclick', e => {
        const blk = e.target.closest('.block-instance');
        if (!blk) return;

        // remove from the DOM
        const cmd = blk.dataset.command;
        blk.remove();

        // also give that block back to the teacher's palette
        const obj = project.objects.find(o => o.id === selectedObjectId);
        if (obj) {
            obj.availableBlocks.push(cmd);
            buildPalette(obj);
            saveProject();
        }
    });

    // ‚úÖ correct
    document.querySelectorAll('#block-library .block')
        .forEach(blockEl => blockEl.addEventListener('dragstart', onBlockDragStart));


    function selectObject(id) {
        selectedObjectId = id;
        document.querySelectorAll('.object').forEach(el => el.classList.remove('selected'));
        const selEl = document.querySelector(`div.object[data-id="${id}"]`);
        if (selEl) selEl.classList.add('selected');
    }

    let dragOffsetX, dragOffsetY;
    function startDrag(e) {
        const objEl = e.currentTarget;
        selectedObjectId = objEl.dataset.id;
        const rect = objEl.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        document.addEventListener('mousemove', dragObject);
        document.addEventListener('mouseup', stopDrag);
    }

    function dragObject(e) {
        const sceneRect = document.getElementById('scene').getBoundingClientRect();
        let x = e.clientX - sceneRect.left - dragOffsetX;
        let y = e.clientY - sceneRect.top - dragOffsetY;
        const obj = project.objects.find(o => o.id === selectedObjectId);
        if (obj) {
            obj.x = x;
            obj.y = y;
            renderScene();
        }
    }

    function stopDrag() {
        document.removeEventListener('mousemove', dragObject);
        document.removeEventListener('mouseup', stopDrag);
        saveProject();
    }

    document.getElementById('loadBackground').addEventListener('click', () => {
        document.getElementById('backgroundUpload').click();
    });

    document.getElementById('backgroundUpload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(evt) {
                project.background = evt.target.result;
                saveProject();
                renderScene();
            };
            reader.readAsDataURL(file);
        }
    });
    document.getElementById('addCostume').addEventListener('click', () => {
        if (!selectedObjectId) return alert("Najprv vyber objekt.");
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.style.display = 'none';
        document.body.appendChild(input);
        input.click();
        input.addEventListener('change', () => {
            const file = input.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const obj = project.objects.find(o => o.id === selectedObjectId);
                    if (!obj.costumes) obj.costumes = [obj.image];
                    obj.costumes.push(event.target.result);
                    saveProject();
                };
                reader.readAsDataURL(file);
            }
        });
        input.remove();
    });
    document.getElementById('nextCostume').addEventListener('click', () => {
        if (!selectedObjectId) return alert("Najprv vyber objekt.");
        const obj = project.objects.find(o => o.id === selectedObjectId);
        if (!obj || !Array.isArray(obj.costumes) || obj.costumes.length === 0) return;

        let currentIndex = obj.costumes.indexOf(obj.image);

        // If current image is not in costumes, treat it as first
        if (currentIndex === -1) currentIndex = 0;

        const nextIndex = (currentIndex + 1) % obj.costumes.length;
        obj.image = obj.costumes[nextIndex];

        saveProject();
        renderScene();
    });

    document.getElementById('addObject').addEventListener('click', () => {
        document.getElementById('objectUpload').click();
    });

    document.getElementById('objectUpload').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(evt) {
                const newObj = {
                    id: Date.now().toString(),
                    image: evt.target.result,
                    x: 50, y: 50,
                    rotation: 0,
                    scale: 1,
                    blocks: [],              // student‚Äôs pre‚Äëwritten program
                    availableBlocks: [],      // teacher‚Äôs palette inventory
                    programmable: true   // ‚Üê ADD THIS LINE
                };

                project.objects.push(newObj);
                saveProject();
                renderScene();
            };
            reader.readAsDataURL(file);
        }
    });

    document.getElementById('copyObject').addEventListener('click', () => {
        if (!selectedObjectId) return alert("Vyberte objekt na kop√≠rovanie.");
        const orig = project.objects.find(obj => obj.id === selectedObjectId);
        if (orig) {
            const copy = { ...orig, id: Date.now().toString(), x: orig.x + 20, y: orig.y + 20 };
            project.objects.push(copy);
            saveProject();
            renderScene();
        }
    });

    document.getElementById('deleteObject').addEventListener('click', () => {
        if (!selectedObjectId) return alert("Vyberte objekt na zru≈°enie.");

        project.objects = project.objects.filter(obj => obj.id !== selectedObjectId);
        selectedObjectId = null;
        saveProject();
        renderScene();
    });
    function toggleProgrammable() {
        if (!selectedObjectId) return;
        const obj = project.objects.find(o => o.id === selectedObjectId);
        obj.programmable = !obj.programmable;
        saveProject();
        alert(`Objekt je teraz ${obj.programmable ? 'programovateƒæn√Ω' : 'statick√Ω'}.`);
        document.getElementById('contextMenu').style.display = 'none';
    }

    window.addEventListener("click", () => {
        document.getElementById("contextMenu").style.display = "none";
    });
    configureBtn.addEventListener('click', () => {
        isConfiguringProgram = !isConfiguringProgram;
        configureBtn.classList.toggle('active', isConfiguringProgram);

        if (isConfiguringProgram) {
            alert('Kliknite na objekt, ktor√Ω chcete programova≈•.');
        } else {
            // cancelled: hide editor if open
            blockEditor.style.display = 'none';
        }
    });
    const programDropdown = document.getElementById('programDropdown');

    // Show dropdown on hover
    configureBtn.addEventListener('mouseenter', () => {
        if (!project?.objects?.length) return;

        const programmable = project.objects.filter(o => o.programmable);
        console.log("Programmable objects:", programmable);

        if (programmable.length === 0) return;

        programDropdown.innerHTML = ""; // clear old
        programmable.forEach(obj => {
            const div = document.createElement('div');
            div.className = 'item';
            div.innerHTML = `<img src="${obj.image}" alt="Objekt"><span>Objekt ${obj.id}</span>`;
            div.onclick = () => {
                selectedObjectId = obj.id;
                openProgramEditorForObject(obj.id);
                isConfiguringProgram = false;
                configureBtn.classList.remove('active');
                programDropdown.style.display = 'none';
            };
            programDropdown.appendChild(div);
        });
        programDropdown.style.display = 'block';
    });

    let dropdownTimeout;

    configureBtn.addEventListener('mouseenter', () => {
        clearTimeout(dropdownTimeout);
        programDropdown.style.display = 'block';
    });

    configureBtn.addEventListener('mouseleave', () => {
        dropdownTimeout = setTimeout(() => {
            programDropdown.style.display = 'none';
        }, 300);
    });

    programDropdown.addEventListener('mouseenter', () => {
        clearTimeout(dropdownTimeout);
        programDropdown.style.display = 'block';
    });

    programDropdown.addEventListener('mouseleave', () => {
        programDropdown.style.display = 'none';
    });



    document.getElementById('editText').addEventListener('click', () => {
        document.getElementById('titleInput').value = project.assignmentTitle || "";
        document.getElementById('descInput').value = project.assignmentDescription || "";

        const style = project.textStyle || {};
        document.getElementById('fontFamilySelect').value = style.font || 'Comic Sans MS';
        document.getElementById('fontSizeSelect').value = style.size || '16px';
        document.getElementById('fontColorInput').value = style.color || '#000000';

        const textarea = document.getElementById('descInput');
        textarea.style.fontFamily = document.getElementById('fontFamilySelect').value;
        textarea.style.fontSize = document.getElementById('fontSizeSelect').value;
        textarea.style.color = document.getElementById('fontColorInput').value;

        document.getElementById('textEditorModal').style.display = 'block';
    });

    document.getElementById('fontFamilySelect').addEventListener('change', function() {
        document.getElementById('descInput').style.fontFamily = this.value;
    });
    document.getElementById('fontSizeSelect').addEventListener('change', function() {
        document.getElementById('descInput').style.fontSize = this.value;
    });
    document.getElementById('fontColorInput').addEventListener('input', function() {
        document.getElementById('descInput').style.color = this.value;
    });

    function closeTextEditor(saveChanges) {
        const modal = document.getElementById('textEditorModal');
        if (saveChanges) {
            const newTitle = document.getElementById('titleInput').value.trim();
            const newDesc = document.getElementById('descInput').value.trim();
            const font = document.getElementById('fontFamilySelect').value;
            const size = document.getElementById('fontSizeSelect').value;
            const color = document.getElementById('fontColorInput').value;

            if (newTitle) project.assignmentTitle = newTitle;
            if (newDesc) project.assignmentDescription = newDesc;
            project.textStyle = { font, size, color };

            saveProject();
            renderTextPreview();
        }
        modal.style.display = 'none';
    }
    function renderTextPreview() {
        const scene = document.getElementById('scene');
        let previewEl = document.getElementById('textPreview');
        if (!previewEl) {
            previewEl = document.createElement('div');
            previewEl.id = 'textPreview';
            previewEl.style.position = 'absolute';
            previewEl.style.top = '20px';
            previewEl.style.left = '20px';
            previewEl.style.maxWidth = '40%';
            previewEl.style.padding = '10px';
            previewEl.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
            previewEl.style.border = '2px dashed #ccc';
            previewEl.style.borderRadius = '10px';
            previewEl.style.zIndex = '20';
            scene.appendChild(previewEl);
        }

        const style = project.textStyle || { font: 'Comic Sans MS', size: '16px', color: '#000000' };
        previewEl.style.fontFamily = style.font;
        previewEl.style.fontSize = style.size;
        previewEl.style.color = style.color;

        previewEl.innerHTML = `<strong>${project.assignmentTitle}</strong><br><br>${project.assignmentDescription.replace(/\n/g, '<br>')}`;
    }



    document.getElementById('saveProject').addEventListener('click', () => {
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(project, null, 2));
        const a = document.createElement('a');
        a.setAttribute("href", dataStr);
        a.setAttribute("download", project.assignmentTitle + ".json");
        document.body.appendChild(a);
        a.click();
        a.remove();
    });


    document.getElementById('downloadZip').addEventListener('click', async () => {
        const zip = new JSZip();

        // Clone project so we can safely modify it for ZIP
        const zipProject = JSON.parse(JSON.stringify(project));

        // Prepare /images/ folder
        const imgFolder = zip.folder("images");

        // Save background
        if (zipProject.background.startsWith("data:")) {
            const bgBlob = await fetch(zipProject.background).then(r => r.blob());
            const bgFilename = "background.png";
            imgFolder.file(bgFilename, bgBlob);
            zipProject.background = "images/" + bgFilename;
        }

        // Save each object image
        for (let i = 0; i < zipProject.objects.length; i++) {
            const obj = zipProject.objects[i];
            const baseFilename = `object${i}`;

            // Save main image
            if (obj.image.startsWith("data:")) {
                const objBlob = await fetch(obj.image).then(r => r.blob());
                const objFilename = `${baseFilename}.png`;
                imgFolder.file(objFilename, objBlob);
                obj.image = "images/" + objFilename;
            }

            // Save costumes if any
            if (obj.costumes && obj.costumes.length > 0) {
                for (let j = 0; j < obj.costumes.length; j++) {
                    const costume = obj.costumes[j];
                    if (costume.startsWith("data:")) {
                        const costumeBlob = await fetch(costume).then(r => r.blob());
                        const costumeFilename = `${baseFilename}_costume${j}.png`;
                        imgFolder.file(costumeFilename, costumeBlob);
                        obj.costumes[j] = "images/" + costumeFilename;
                    }
                }
            }
        }

        // Save JSON
        zip.file("projekt.json", JSON.stringify(zipProject, null, 2));

        // Download
        zip.generateAsync({ type: "blob" }).then(function (content) {
            saveAs(content, `${zipProject.assignmentTitle || 'projekt'}.zip`);
        });
    });

    document.getElementById('close-editor-btn').onclick = () => {
        runtimeControls.style.display = 'none';
        previewStop.style.display     = 'none';

        blockEditor.style.display = 'none';
        isConfiguringProgram = false;
        configureBtn.classList.remove('active');
    };


    document.getElementById('transformObject').addEventListener('click', () => {
        if (!selectedObjectId) return alert("Najprv vyber objekt.");
        const obj = project.objects.find(o => o.id === selectedObjectId);
        const newRotation = prompt("Zadajte rot√°ciu objektu v stup≈àoch:", obj.rotation);
        const newScale = prompt("Zadajte mierku objektu (napr. 1 = 100%):", obj.scale);
        if (newRotation !== null) obj.rotation = parseFloat(newRotation) || 0;
        if (newScale !== null) obj.scale = parseFloat(newScale) || 1;
        saveProject();
        renderScene();
    });

    loadProject().then(p => {
        project = p;

        // ‚îÄ‚îÄ make sure each object has our new field ‚îÄ‚îÄ
        project.objects.forEach(o => {
            if (!Array.isArray(o.availableBlocks)) {
                o.availableBlocks = [];
            }
        });

        renderScene();
    });
    const addCostumeBtn = document.getElementById('addCostume');
    const costumePreview = document.getElementById('costumePreview');

    addCostumeBtn.addEventListener('mouseenter', () => {
        if (!selectedObjectId) return;
        const obj = project.objects.find(o => o.id === selectedObjectId);
        if (!obj) return;

        costumePreview.innerHTML = "";

        const allCostumes = [obj.image].concat(obj.costumes || []);
        allCostumes.forEach((imgSrc, index) => {
            const img = document.createElement('img');
            img.src = imgSrc;
            img.alt = `Kost√Ωm ${index + 1}`;
            img.style.cssText = `
            height: 60px;
            margin-right: 6px;
            border-radius: 8px;
            border: 2px solid #ccc;
        `;
            costumePreview.appendChild(img);
        });

        const rect = addCostumeBtn.getBoundingClientRect();
        costumePreview.style.top = `${rect.bottom + 5}px`;
        costumePreview.style.left = `${rect.left}px`;
        costumePreview.style.display = "block";
    });

    addCostumeBtn.addEventListener('mouseleave', () => {
        setTimeout(() => costumePreview.style.display = "none", 400);
    });
    costumePreview.addEventListener('mouseenter', () => {
        costumePreview.style.display = "block";
    });
    costumePreview.addEventListener('mouseleave', () => {
        costumePreview.style.display = "none";
    });

    let draggedBlock = null;

    // Called on dragstart
    function onBlockDragStart(e) {
        draggedBlock = e.currentTarget;
        e.currentTarget.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', e.currentTarget.dataset.command);
    }

    function onBlockDragEnd(e) {
        e.currentTarget.classList.remove('dragging');
        draggedBlock = null;
    }


    // Given a container and a Y‚Äëcoordinate, find the block we're hovering above
    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.block-instance:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset, element: child };
            }
            return closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // After you finish a drop, rewrite obj.blocks from the DOM order
    function serializeBlock(blockEl) {
        const command = blockEl.dataset.command;
        const paramInput = blockEl.querySelector('input');
        const param = paramInput ? paramInput.value : null;

        const blockData = { command };
        if (param !== null) blockData.param = param;

        const childrenContainer = blockEl.querySelector('.block-children');
        if (childrenContainer) {
            const children = Array.from(childrenContainer.children)
                .filter(el => el.classList.contains('block-instance'))
                .map(childEl => serializeBlock(childEl));
            blockData.children = children;
        }

        return blockData;
    }

    function persistBlockOrder() {
        if (!selectedObjectId) return;
        const obj = project.objects.find(o => o.id === selectedObjectId);

        obj.blocks = Array.from(programArea.children)
            .filter(el => el.classList.contains('block-instance'))
            .map(blockEl => serializeBlock(blockEl));

        saveProject();
    }

    function renderBlock(blockData) {
        const block = document.createElement('div');
        block.className = 'block block-instance';
        block.dataset.command = blockData.command;
        block.draggable = true;
        block.addEventListener('dragstart', onBlockDragStart);
        block.addEventListener('dragend', onBlockDragEnd);

        const template = document.querySelector(`#block-library .block[data-command="${blockData.command}"]`);
        if (template) {
            block.innerHTML = template.innerHTML;
        } else {
            block.textContent = blockData.command;
        }
// If opakuj st√°le doesn't have .block-children yet, add it
        if (blockData.command === "opakuj st√°le" && !block.querySelector('.block-children')) {
            const childDiv = document.createElement('div');
            childDiv.className = 'block-children';
            block.appendChild(childDiv);
        }

        // If it has a parameter, set it
        const paramInput = block.querySelector('input');
        if (paramInput && blockData.param !== undefined) {
            paramInput.value = blockData.param;
        }

        // If it has children, recursively render them
        const childContainer = block.querySelector('.block-children');
        if (childContainer && Array.isArray(blockData.children)) {
            blockData.children.forEach(child => {
                const childBlock = renderBlock(child);
                childContainer.appendChild(childBlock);
            });
        }

        return block;
    }
    function enableNestedDrops() {
        document.querySelectorAll('.block-children').forEach(childContainer => {
            childContainer.addEventListener('dragover', e => e.preventDefault());

            childContainer.addEventListener('drop', e => {
                e.preventDefault();
                e.stopPropagation();

                if (!draggedBlock) return;

                const obj = project.objects.find(o => o.id === selectedObjectId);
                if (!obj) return;

                const isNew = !programArea.contains(draggedBlock) && !draggedBlock.closest('.block-children');

                if (isNew) {
                    const cmd = draggedBlock.dataset.command;
                    const idx = obj.availableBlocks.indexOf(cmd);
                    if (idx === -1) {
                        alert(`Nie je dostupn√Ω ƒèal≈°√≠ blok: ${cmd}`);
                        return;
                    }
                    obj.availableBlocks.splice(idx, 1);
                    saveProject();
                    buildPalette(obj);

                    const newBlock = renderBlock({
                        command: draggedBlock.dataset.command,
                        param: draggedBlock.querySelector('input')?.value ?? null,

                        children: []
                    });

                    const after = getDragAfterElement(childContainer, e.clientY);
                    if (!after) {
                        childContainer.appendChild(newBlock);
                    } else {
                        childContainer.insertBefore(newBlock, after);
                    }
                } else {
                    // üß† Prevent dragging parent into its own child
                    if (draggedBlock.contains(childContainer)) return;

                    const after = getDragAfterElement(childContainer, e.clientY);
                    if (!after) {
                        childContainer.appendChild(draggedBlock);
                    } else {
                        childContainer.insertBefore(draggedBlock, after);
                    }
                }
                enableNestedDrops();

                persistBlockOrder();
                draggedBlock = null;
            });
        });
    }





</script>
</body>
</html>